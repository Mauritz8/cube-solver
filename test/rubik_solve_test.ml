open Rubik.Cube
open Rubik.Move
open Rubik.Solve

(* All scrambles are generated by
   https://ruwix.com/puzzle-scramble-generator/?type=rubiks-cube *)
(* White on top and green on the front *)

let assert_cross_solved cube =
  let fail_message =
    Printf.sprintf "Cross is solved: %s" (Utils.cube_to_string cube)
  in
  Alcotest.(check bool) fail_message true (cross_is_solved cube)

let assert_corners_first_layer_solved cube =
  let fail_message =
    Printf.sprintf "Corners in first layer are solved: %s"
      (Utils.cube_to_string cube)
  in
  Alcotest.(check bool) fail_message true (corners_first_layer_solved cube)

let solve_cross_already_solved () =
  let cube =
    {
      top_face =
        {
          fst = { fst = BLUE; snd = WHITE; trd = YELLOW };
          snd = { fst = WHITE; snd = WHITE; trd = WHITE };
          trd = { fst = WHITE; snd = WHITE; trd = RED };
        };
      top_layer =
        {
          front = { fst = BLUE; snd = GREEN; trd = GREEN };
          right = { fst = YELLOW; snd = RED; trd = BLUE };
          back = { fst = RED; snd = BLUE; trd = YELLOW };
          left = { fst = ORANGE; snd = ORANGE; trd = RED };
        };
      middle_layer =
        {
          front = { fst = YELLOW; snd = GREEN; trd = BLUE };
          right = { fst = ORANGE; snd = RED; trd = RED };
          back = { fst = BLUE; snd = BLUE; trd = RED };
          left = { fst = YELLOW; snd = ORANGE; trd = BLUE };
        };
      bottom_layer =
        {
          front = { fst = YELLOW; snd = RED; trd = GREEN };
          right = { fst = ORANGE; snd = ORANGE; trd = ORANGE };
          back = { fst = BLUE; snd = YELLOW; trd = WHITE };
          left = { fst = RED; snd = ORANGE; trd = GREEN };
        };
      bottom_face =
        {
          fst = { fst = ORANGE; snd = GREEN; trd = WHITE };
          snd = { fst = GREEN; snd = YELLOW; trd = YELLOW };
          trd = { fst = GREEN; snd = GREEN; trd = WHITE };
        };
    }
  in
  match solve_cross cube with
  | Error e -> failwith e
  | Ok solution -> assert_cross_solved solution.cube

(* all edges are one the correct face but need to swap places with each other *)
let solve_cross_edges_needs_to_swap () =
  let cube =
    {
      top_face =
        {
          fst = { fst = RED; snd = WHITE; trd = RED };
          snd = { fst = WHITE; snd = WHITE; trd = WHITE };
          trd = { fst = GREEN; snd = WHITE; trd = GREEN };
        };
      top_layer =
        {
          front = { fst = ORANGE; snd = BLUE; trd = YELLOW };
          right = { fst = RED; snd = ORANGE; trd = WHITE };
          back = { fst = GREEN; snd = RED; trd = YELLOW };
          left = { fst = BLUE; snd = GREEN; trd = WHITE };
        };
      middle_layer =
        {
          front = { fst = YELLOW; snd = GREEN; trd = ORANGE };
          right = { fst = BLUE; snd = RED; trd = YELLOW };
          back = { fst = ORANGE; snd = BLUE; trd = YELLOW };
          left = { fst = BLUE; snd = ORANGE; trd = RED };
        };
      bottom_layer =
        {
          front = { fst = YELLOW; snd = YELLOW; trd = BLUE };
          right = { fst = RED; snd = RED; trd = WHITE };
          back = { fst = ORANGE; snd = RED; trd = YELLOW };
          left = { fst = ORANGE; snd = GREEN; trd = ORANGE };
        };
      bottom_face =
        {
          fst = { fst = BLUE; snd = GREEN; trd = WHITE };
          snd = { fst = ORANGE; snd = YELLOW; trd = BLUE };
          trd = { fst = GREEN; snd = GREEN; trd = BLUE };
        };
    }
  in
  match solve_cross cube with
  | Error e -> failwith e
  | Ok solution -> assert_cross_solved solution.cube

(* Scramble: D2 R2 D' L2 U L R2 U' D R' D' R B R' F D F' R B' U F2 B U2 F2 L *)
let solve_cross_test_1 () =
  let cube =
    {
      top_face =
        {
          fst = { fst = WHITE; snd = GREEN; trd = RED };
          snd = { fst = BLUE; snd = WHITE; trd = GREEN };
          trd = { fst = YELLOW; snd = ORANGE; trd = YELLOW };
        };
      top_layer =
        {
          front = { fst = RED; snd = BLUE; trd = RED };
          right = { fst = GREEN; snd = ORANGE; trd = BLUE };
          back = { fst = WHITE; snd = RED; trd = ORANGE };
          left = { fst = GREEN; snd = YELLOW; trd = BLUE };
        };
      middle_layer =
        {
          front = { fst = YELLOW; snd = GREEN; trd = ORANGE };
          right = { fst = YELLOW; snd = RED; trd = YELLOW };
          back = { fst = RED; snd = BLUE; trd = ORANGE };
          left = { fst = WHITE; snd = ORANGE; trd = GREEN };
        };
      bottom_layer =
        {
          front = { fst = WHITE; snd = BLUE; trd = YELLOW };
          right = { fst = ORANGE; snd = RED; trd = BLUE };
          back = { fst = WHITE; snd = BLUE; trd = BLUE };
          left = { fst = ORANGE; snd = GREEN; trd = GREEN };
        };
      bottom_face =
        {
          fst = { fst = RED; snd = RED; trd = GREEN };
          snd = { fst = WHITE; snd = YELLOW; trd = WHITE };
          trd = { fst = YELLOW; snd = WHITE; trd = ORANGE };
        };
    }
  in
  match solve_cross cube with
  | Error e -> failwith e
  | Ok solution -> assert_cross_solved solution.cube

(* Scramble: D2 B2 F' D' L' B U F B' L' F2 L2 F2 D L2 U2 B2 U' R2 L F' R' B F2 U *)
let solve_cross_test_2 () =
  let cube =
    {
      top_face =
        {
          fst = { fst = WHITE; snd = WHITE; trd = BLUE };
          snd = { fst = BLUE; snd = WHITE; trd = GREEN };
          trd = { fst = BLUE; snd = RED; trd = GREEN };
        };
      top_layer =
        {
          front = { fst = WHITE; snd = GREEN; trd = RED };
          right = { fst = WHITE; snd = YELLOW; trd = RED };
          back = { fst = YELLOW; snd = GREEN; trd = RED };
          left = { fst = BLUE; snd = WHITE; trd = ORANGE };
        };
      middle_layer =
        {
          front = { fst = YELLOW; snd = GREEN; trd = BLUE };
          right = { fst = ORANGE; snd = RED; trd = GREEN };
          back = { fst = ORANGE; snd = BLUE; trd = RED };
          left = { fst = YELLOW; snd = ORANGE; trd = BLUE };
        };
      bottom_layer =
        {
          front = { fst = YELLOW; snd = BLUE; trd = GREEN };
          right = { fst = ORANGE; snd = ORANGE; trd = YELLOW };
          back = { fst = BLUE; snd = WHITE; trd = GREEN };
          left = { fst = RED; snd = WHITE; trd = GREEN };
        };
      bottom_face =
        {
          fst = { fst = ORANGE; snd = RED; trd = WHITE };
          snd = { fst = RED; snd = YELLOW; trd = YELLOW };
          trd = { fst = YELLOW; snd = ORANGE; trd = ORANGE };
        };
    }
  in
  match solve_cross cube with
  | Error e -> failwith e
  | Ok solution -> assert_cross_solved solution.cube

let solve_corners_first_layer_test_1 () =
  let scramble = "D' R F D L F L' U L F U L' U B' L' U B R D L'" in
  let scramble_moves =
    String.split_on_char ' ' scramble
    |> List.map (fun move_notation ->
           Result.get_ok (notation_to_move move_notation))
  in
  let cube = List.fold_left make_move solved_cube scramble_moves in
  match solve_cross cube with
  | Error e -> failwith e
  | Ok cross_solution -> (
      assert_cross_solved cross_solution.cube;

      match solve_corners_first_layer cross_solution.cube with
      | Error e -> failwith e
      | Ok corners_first_layer_solution ->
          assert_cross_solved corners_first_layer_solution.cube;
          assert_corners_first_layer_solved corners_first_layer_solution.cube;
          ())

let solve_corners_first_layer_test_2 () =
  let scramble = "B F L U L' U L' U R' F L' F' L B' L D' B U L F'" in
  let scramble_moves =
    String.split_on_char ' ' scramble
    |> List.map (fun move_notation ->
           Result.get_ok (notation_to_move move_notation))
  in
  let cube = List.fold_left make_move solved_cube scramble_moves in
  match solve_cross cube with
  | Error e -> failwith e
  | Ok cross_solution -> (
      assert_cross_solved cross_solution.cube;

      match solve_corners_first_layer cross_solution.cube with
      | Error e -> failwith e
      | Ok corners_first_layer_solution ->
          assert_cross_solved corners_first_layer_solution.cube;
          assert_corners_first_layer_solved corners_first_layer_solution.cube;
          ())

let () =
  let open Alcotest in
  run "Solve"
    [
      ( "cross",
        [
          test_case "already solved" `Quick solve_cross_already_solved;
          test_case "only edges need to swap" `Quick
            solve_cross_edges_needs_to_swap;
          test_case "random scramble #1" `Quick solve_cross_test_1;
          test_case "random scramble #2" `Quick solve_cross_test_2;
        ] );
      ( "corners first layer",
        [
          test_case "random scramble #1" `Quick solve_corners_first_layer_test_1;
          test_case "random scramble #2" `Quick solve_corners_first_layer_test_2;
        ] );
    ]
